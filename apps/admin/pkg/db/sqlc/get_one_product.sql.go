// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: get_one_product.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/jackc/pgx/v5/pgtype"
)

const getProduct = `-- name: GetProduct :one
SELECT
    p.id AS product_id,
    p.name AS product_name,
    p.description AS product_description,
    p.rating,
    p.is_featured,
    p.is_archived,
    p.has_variants,
    p.category_id,
    p.store_id,
    p.variants AS variants_order,
    COALESCE(
        JSON_AGG(
            JSON_BUILD_OBJECT(
                'variant_id', pv.id,
                'sku', pv.sku,
                'quantity', pv.quantity,
                'price', pv.price,
                'discounted_price', pv.discounted_price,
                'cost_price', pv.cost_price,
                'created_at', pv.created_at,
                'updated_at', pv.updated_at,
                'options', (
                    SELECT JSON_OBJECT_AGG(v.name, vo.value)
                    FROM variant_options vo
                    LEFT JOIN product_variant_options pvo ON vo.id = pvo.variant_option_id
                    LEFT JOIN variants v ON vo.variant_id = v.id
                    WHERE pvo.product_variant_id = pv.id
                ),
                'images', COALESCE(
                    (
                      SELECT json_agg(i.image_id)
                      FROM product_variant_images pvi
                      JOIN images i ON i.id = pvi.image_id
                      WHERE pvi.product_variant_id = pv.id
                    ),
                    '[]'::json
                  )
            )
        ) FILTER (WHERE pv.id IS NOT NULL), '[]'
    ) AS product_variants,
    COALESCE(
        (SELECT 
            JSON_AGG(
                JSON_BUILD_OBJECT(
                    'variant_id', gv.variant_id,
                    'name', gv.variant_name,
                    'options', gv.options
                )
                ORDER BY gv.ord
            )
         FROM (
             SELECT
                 v.id AS variant_id,
                 v.name AS variant_name,
                 JSON_AGG(
                     JSON_BUILD_OBJECT(
                         'id', vo.id,
                         'value', vo.value,
                         'data', vo.data
                     )
                 ) AS options,
                 idx.ord
             FROM
                 variants v
             LEFT JOIN variant_options vo ON v.id = vo.variant_id
             LEFT JOIN product_variant_options pvo ON vo.id = pvo.variant_option_id
             LEFT JOIN product_variants pv_inner ON pvo.product_variant_id = pv_inner.id
             LEFT JOIN LATERAL (
                 SELECT ordinality AS ord
                 FROM jsonb_array_elements_text(p.variants) WITH ORDINALITY
                 WHERE value = v.id::text
             ) idx ON true
             WHERE
                 pv_inner.product_id = p.id
             GROUP BY
                 v.id, v.name, idx.ord
         ) gv
        ),
        '[]'::JSON
    ) AS variants
FROM
    products p
LEFT JOIN
    product_variants pv ON p.id = pv.product_id
WHERE
    p.id = $1 AND p.store_id = $2
GROUP BY
    p.id
`

type GetProductParams struct {
	ID      string `json:"id"`
	StoreID string `json:"store_id"`
}

type GetProductRow struct {
	ProductID          string          `json:"product_id"`
	ProductName        string          `json:"product_name"`
	ProductDescription pgtype.Text     `json:"product_description"`
	Rating             pgtype.Float8   `json:"rating"`
	IsFeatured         pgtype.Bool     `json:"is_featured"`
	IsArchived         pgtype.Bool     `json:"is_archived"`
	HasVariants        pgtype.Bool     `json:"has_variants"`
	CategoryID         string          `json:"category_id"`
	StoreID            string          `json:"store_id"`
	VariantsOrder      json.RawMessage `json:"variants_order"`
	ProductVariants    interface{}     `json:"product_variants"`
	Variants           interface{}     `json:"variants"`
}

func (q *Queries) GetProduct(ctx context.Context, arg GetProductParams) (GetProductRow, error) {
	row := q.db.QueryRow(ctx, getProduct, arg.ID, arg.StoreID)
	var i GetProductRow
	err := row.Scan(
		&i.ProductID,
		&i.ProductName,
		&i.ProductDescription,
		&i.Rating,
		&i.IsFeatured,
		&i.IsArchived,
		&i.HasVariants,
		&i.CategoryID,
		&i.StoreID,
		&i.VariantsOrder,
		&i.ProductVariants,
		&i.Variants,
	)
	return i, err
}
