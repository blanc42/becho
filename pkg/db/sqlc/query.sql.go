// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAddress = `-- name: CreateAddress :one
INSERT INTO addresses (id, created_at, updated_at, address_line_1, address_line_2, city, pincode, country_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, created_at, updated_at, address_line_1, address_line_2, city, pincode, country_id
`

type CreateAddressParams struct {
	ID           string           `json:"id"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	UpdatedAt    pgtype.Timestamp `json:"updated_at"`
	AddressLine1 string           `json:"address_line_1"`
	AddressLine2 pgtype.Text      `json:"address_line_2"`
	City         string           `json:"city"`
	Pincode      string           `json:"pincode"`
	CountryID    string           `json:"country_id"`
}

// Addresses
func (q *Queries) CreateAddress(ctx context.Context, arg CreateAddressParams) (Address, error) {
	row := q.db.QueryRow(ctx, createAddress,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.AddressLine1,
		arg.AddressLine2,
		arg.City,
		arg.Pincode,
		arg.CountryID,
	)
	var i Address
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.City,
		&i.Pincode,
		&i.CountryID,
	)
	return i, err
}

const createCart = `-- name: CreateCart :one
INSERT INTO carts (id, created_at, updated_at, customer_id, total_price, total_discounted_price, total_quantity)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, created_at, updated_at, customer_id, total_price, total_discounted_price, total_quantity
`

type CreateCartParams struct {
	ID                   string           `json:"id"`
	CreatedAt            pgtype.Timestamp `json:"created_at"`
	UpdatedAt            pgtype.Timestamp `json:"updated_at"`
	CustomerID           string           `json:"customer_id"`
	TotalPrice           float64          `json:"total_price"`
	TotalDiscountedPrice pgtype.Float8    `json:"total_discounted_price"`
	TotalQuantity        int32            `json:"total_quantity"`
}

// Carts
func (q *Queries) CreateCart(ctx context.Context, arg CreateCartParams) (Cart, error) {
	row := q.db.QueryRow(ctx, createCart,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.CustomerID,
		arg.TotalPrice,
		arg.TotalDiscountedPrice,
		arg.TotalQuantity,
	)
	var i Cart
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CustomerID,
		&i.TotalPrice,
		&i.TotalDiscountedPrice,
		&i.TotalQuantity,
	)
	return i, err
}

const createCartItem = `-- name: CreateCartItem :one
INSERT INTO cart_items (id, created_at, updated_at, product_item_id, quantity, cart_id)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, created_at, updated_at, product_item_id, quantity, cart_id
`

type CreateCartItemParams struct {
	ID            string           `json:"id"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	ProductItemID string           `json:"product_item_id"`
	Quantity      int32            `json:"quantity"`
	CartID        string           `json:"cart_id"`
}

// Cart Items
func (q *Queries) CreateCartItem(ctx context.Context, arg CreateCartItemParams) (CartItem, error) {
	row := q.db.QueryRow(ctx, createCartItem,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.ProductItemID,
		arg.Quantity,
		arg.CartID,
	)
	var i CartItem
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProductItemID,
		&i.Quantity,
		&i.CartID,
	)
	return i, err
}

const createCategory = `-- name: CreateCategory :one
INSERT INTO categories (id, created_at, updated_at, name, description, store_id, parent_category_id, variants)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, created_at, updated_at, name, description, store_id, parent_category_id, variants
`

type CreateCategoryParams struct {
	ID               string           `json:"id"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	UpdatedAt        pgtype.Timestamp `json:"updated_at"`
	Name             string           `json:"name"`
	Description      pgtype.Text      `json:"description"`
	StoreID          string           `json:"store_id"`
	ParentCategoryID pgtype.Text      `json:"parent_category_id"`
	Variants         json.RawMessage  `json:"variants"`
}

// Categories
func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (Category, error) {
	row := q.db.QueryRow(ctx, createCategory,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Name,
		arg.Description,
		arg.StoreID,
		arg.ParentCategoryID,
		arg.Variants,
	)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.StoreID,
		&i.ParentCategoryID,
		&i.Variants,
	)
	return i, err
}

const createCountry = `-- name: CreateCountry :one
INSERT INTO countries (id, created_at, updated_at, country)
VALUES ($1, $2, $3, $4)
RETURNING id, created_at, updated_at, country
`

type CreateCountryParams struct {
	ID        string           `json:"id"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
	Country   string           `json:"country"`
}

// Countries
func (q *Queries) CreateCountry(ctx context.Context, arg CreateCountryParams) (Country, error) {
	row := q.db.QueryRow(ctx, createCountry,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Country,
	)
	var i Country
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Country,
	)
	return i, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (id, created_at, updated_at, order_number, payment_status, order_status, store_id, customer_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, created_at, updated_at, order_number, payment_status, order_status, store_id, customer_id
`

type CreateOrderParams struct {
	ID            string           `json:"id"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	OrderNumber   string           `json:"order_number"`
	PaymentStatus string           `json:"payment_status"`
	OrderStatus   string           `json:"order_status"`
	StoreID       string           `json:"store_id"`
	CustomerID    string           `json:"customer_id"`
}

// Orders
func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.OrderNumber,
		arg.PaymentStatus,
		arg.OrderStatus,
		arg.StoreID,
		arg.CustomerID,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OrderNumber,
		&i.PaymentStatus,
		&i.OrderStatus,
		&i.StoreID,
		&i.CustomerID,
	)
	return i, err
}

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO order_items (id, created_at, updated_at, product_item_id, quantity, order_id)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, created_at, updated_at, product_item_id, quantity, order_id
`

type CreateOrderItemParams struct {
	ID            string           `json:"id"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	ProductItemID string           `json:"product_item_id"`
	Quantity      int32            `json:"quantity"`
	OrderID       string           `json:"order_id"`
}

// Order Items
func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (OrderItem, error) {
	row := q.db.QueryRow(ctx, createOrderItem,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.ProductItemID,
		arg.Quantity,
		arg.OrderID,
	)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProductItemID,
		&i.Quantity,
		&i.OrderID,
	)
	return i, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (id, created_at, updated_at, name, description, rating, is_featured, is_archived, has_variants, category_id, store_id, category_name, variants)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
RETURNING id, created_at, updated_at, name, description, rating, is_featured, is_archived, has_variants, category_id, store_id, category_name, variants
`

type CreateProductParams struct {
	ID           string           `json:"id"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	UpdatedAt    pgtype.Timestamp `json:"updated_at"`
	Name         string           `json:"name"`
	Description  pgtype.Text      `json:"description"`
	Rating       pgtype.Float8    `json:"rating"`
	IsFeatured   pgtype.Bool      `json:"is_featured"`
	IsArchived   pgtype.Bool      `json:"is_archived"`
	HasVariants  pgtype.Bool      `json:"has_variants"`
	CategoryID   string           `json:"category_id"`
	StoreID      string           `json:"store_id"`
	CategoryName string           `json:"category_name"`
	Variants     json.RawMessage  `json:"variants"`
}

// Products
func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Name,
		arg.Description,
		arg.Rating,
		arg.IsFeatured,
		arg.IsArchived,
		arg.HasVariants,
		arg.CategoryID,
		arg.StoreID,
		arg.CategoryName,
		arg.Variants,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.Rating,
		&i.IsFeatured,
		&i.IsArchived,
		&i.HasVariants,
		&i.CategoryID,
		&i.StoreID,
		&i.CategoryName,
		&i.Variants,
	)
	return i, err
}

const createProductImage = `-- name: CreateProductImage :one
INSERT INTO product_images (id, created_at, updated_at, product_item_id, image_url)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, created_at, updated_at, product_item_id, image_url
`

type CreateProductImageParams struct {
	ID            string           `json:"id"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	ProductItemID string           `json:"product_item_id"`
	ImageUrl      string           `json:"image_url"`
}

// Product Images
func (q *Queries) CreateProductImage(ctx context.Context, arg CreateProductImageParams) (ProductImage, error) {
	row := q.db.QueryRow(ctx, createProductImage,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.ProductItemID,
		arg.ImageUrl,
	)
	var i ProductImage
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProductItemID,
		&i.ImageUrl,
	)
	return i, err
}

const createProductItem = `-- name: CreateProductItem :one
INSERT INTO product_items (id, created_at, updated_at, product_id, sku, quantity, price, discounted_price, cost_price, options)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, created_at, updated_at, product_id, sku, quantity, price, discounted_price, cost_price, options
`

type CreateProductItemParams struct {
	ID              string           `json:"id"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	UpdatedAt       pgtype.Timestamp `json:"updated_at"`
	ProductID       string           `json:"product_id"`
	Sku             string           `json:"sku"`
	Quantity        int32            `json:"quantity"`
	Price           float64          `json:"price"`
	DiscountedPrice pgtype.Float8    `json:"discounted_price"`
	CostPrice       pgtype.Float8    `json:"cost_price"`
	Options         json.RawMessage  `json:"options"`
}

// Product Items
func (q *Queries) CreateProductItem(ctx context.Context, arg CreateProductItemParams) (ProductItem, error) {
	row := q.db.QueryRow(ctx, createProductItem,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.ProductID,
		arg.Sku,
		arg.Quantity,
		arg.Price,
		arg.DiscountedPrice,
		arg.CostPrice,
		arg.Options,
	)
	var i ProductItem
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProductID,
		&i.Sku,
		&i.Quantity,
		&i.Price,
		&i.DiscountedPrice,
		&i.CostPrice,
		&i.Options,
	)
	return i, err
}

const createStore = `-- name: CreateStore :one
INSERT INTO stores (id, created_at, updated_at, name, description, user_id)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, created_at, updated_at, name, description, user_id
`

type CreateStoreParams struct {
	ID          string           `json:"id"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
	Name        string           `json:"name"`
	Description pgtype.Text      `json:"description"`
	UserID      string           `json:"user_id"`
}

// Stores
func (q *Queries) CreateStore(ctx context.Context, arg CreateStoreParams) (Store, error) {
	row := q.db.QueryRow(ctx, createStore,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Name,
		arg.Description,
		arg.UserID,
	)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.UserID,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (id, created_at, updated_at, username, email, password, role, store_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, created_at, updated_at, username, email, password, role, store_id
`

type CreateUserParams struct {
	ID        string           `json:"id"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
	Username  string           `json:"username"`
	Email     string           `json:"email"`
	Password  string           `json:"password"`
	Role      string           `json:"role"`
	StoreID   pgtype.Text      `json:"store_id"`
}

// Users
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Username,
		arg.Email,
		arg.Password,
		arg.Role,
		arg.StoreID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.StoreID,
	)
	return i, err
}

const createVariant = `-- name: CreateVariant :one
INSERT INTO variants (id, created_at, updated_at, name, description, options, store_id)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, created_at, updated_at, name, description, options, store_id
`

type CreateVariantParams struct {
	ID          string           `json:"id"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
	Name        string           `json:"name"`
	Description pgtype.Text      `json:"description"`
	Options     json.RawMessage  `json:"options"`
	StoreID     string           `json:"store_id"`
}

// Variants
func (q *Queries) CreateVariant(ctx context.Context, arg CreateVariantParams) (Variant, error) {
	row := q.db.QueryRow(ctx, createVariant,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Name,
		arg.Description,
		arg.Options,
		arg.StoreID,
	)
	var i Variant
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.Options,
		&i.StoreID,
	)
	return i, err
}

const deleteAddress = `-- name: DeleteAddress :exec
DELETE FROM addresses
WHERE id = $1
`

func (q *Queries) DeleteAddress(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteAddress, id)
	return err
}

const deleteCart = `-- name: DeleteCart :exec
DELETE FROM carts
WHERE id = $1
`

func (q *Queries) DeleteCart(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteCart, id)
	return err
}

const deleteCartItem = `-- name: DeleteCartItem :exec
DELETE FROM cart_items
WHERE id = $1
`

func (q *Queries) DeleteCartItem(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteCartItem, id)
	return err
}

const deleteCategory = `-- name: DeleteCategory :exec
DELETE FROM categories
WHERE id = $1 AND store_id = $2
`

type DeleteCategoryParams struct {
	ID      string `json:"id"`
	StoreID string `json:"store_id"`
}

func (q *Queries) DeleteCategory(ctx context.Context, arg DeleteCategoryParams) error {
	_, err := q.db.Exec(ctx, deleteCategory, arg.ID, arg.StoreID)
	return err
}

const deleteCountry = `-- name: DeleteCountry :exec
DELETE FROM countries
WHERE id = $1
`

func (q *Queries) DeleteCountry(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteCountry, id)
	return err
}

const deleteOrder = `-- name: DeleteOrder :exec
DELETE FROM orders
WHERE id = $1
`

func (q *Queries) DeleteOrder(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteOrder, id)
	return err
}

const deleteOrderItem = `-- name: DeleteOrderItem :exec
DELETE FROM order_items
WHERE id = $1
`

func (q *Queries) DeleteOrderItem(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteOrderItem, id)
	return err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM products
WHERE id = $1 AND store_id = $2
`

type DeleteProductParams struct {
	ID      string `json:"id"`
	StoreID string `json:"store_id"`
}

func (q *Queries) DeleteProduct(ctx context.Context, arg DeleteProductParams) error {
	_, err := q.db.Exec(ctx, deleteProduct, arg.ID, arg.StoreID)
	return err
}

const deleteProductImage = `-- name: DeleteProductImage :exec
DELETE FROM product_images
WHERE id = $1
`

func (q *Queries) DeleteProductImage(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteProductImage, id)
	return err
}

const deleteProductItem = `-- name: DeleteProductItem :exec
DELETE FROM product_items
WHERE id = $1
`

func (q *Queries) DeleteProductItem(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteProductItem, id)
	return err
}

const deleteStore = `-- name: DeleteStore :exec
DELETE FROM stores
WHERE id = $1
`

func (q *Queries) DeleteStore(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteStore, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const deleteVariant = `-- name: DeleteVariant :exec
DELETE FROM variants
WHERE id = $1 AND store_id = $2
`

type DeleteVariantParams struct {
	ID      string `json:"id"`
	StoreID string `json:"store_id"`
}

func (q *Queries) DeleteVariant(ctx context.Context, arg DeleteVariantParams) error {
	_, err := q.db.Exec(ctx, deleteVariant, arg.ID, arg.StoreID)
	return err
}

const getAddress = `-- name: GetAddress :one
SELECT id, created_at, updated_at, address_line_1, address_line_2, city, pincode, country_id FROM addresses
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetAddress(ctx context.Context, id string) (Address, error) {
	row := q.db.QueryRow(ctx, getAddress, id)
	var i Address
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.City,
		&i.Pincode,
		&i.CountryID,
	)
	return i, err
}

const getCart = `-- name: GetCart :one
SELECT id, created_at, updated_at, customer_id, total_price, total_discounted_price, total_quantity FROM carts
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCart(ctx context.Context, id string) (Cart, error) {
	row := q.db.QueryRow(ctx, getCart, id)
	var i Cart
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CustomerID,
		&i.TotalPrice,
		&i.TotalDiscountedPrice,
		&i.TotalQuantity,
	)
	return i, err
}

const getCartByCustomer = `-- name: GetCartByCustomer :one
SELECT id, created_at, updated_at, customer_id, total_price, total_discounted_price, total_quantity FROM carts
WHERE customer_id = $1 LIMIT 1
`

func (q *Queries) GetCartByCustomer(ctx context.Context, customerID string) (Cart, error) {
	row := q.db.QueryRow(ctx, getCartByCustomer, customerID)
	var i Cart
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CustomerID,
		&i.TotalPrice,
		&i.TotalDiscountedPrice,
		&i.TotalQuantity,
	)
	return i, err
}

const getCartItem = `-- name: GetCartItem :one
SELECT id, created_at, updated_at, product_item_id, quantity, cart_id FROM cart_items
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCartItem(ctx context.Context, id string) (CartItem, error) {
	row := q.db.QueryRow(ctx, getCartItem, id)
	var i CartItem
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProductItemID,
		&i.Quantity,
		&i.CartID,
	)
	return i, err
}

const getCategory = `-- name: GetCategory :one
SELECT id, created_at, updated_at, name, description, store_id, parent_category_id, variants FROM categories
WHERE id = $1  LIMIT 1
`

func (q *Queries) GetCategory(ctx context.Context, id string) (Category, error) {
	row := q.db.QueryRow(ctx, getCategory, id)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.StoreID,
		&i.ParentCategoryID,
		&i.Variants,
	)
	return i, err
}

const getCountry = `-- name: GetCountry :one
SELECT id, created_at, updated_at, country FROM countries
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCountry(ctx context.Context, id string) (Country, error) {
	row := q.db.QueryRow(ctx, getCountry, id)
	var i Country
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Country,
	)
	return i, err
}

const getOrder = `-- name: GetOrder :one
SELECT id, created_at, updated_at, order_number, payment_status, order_status, store_id, customer_id FROM orders
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetOrder(ctx context.Context, id string) (Order, error) {
	row := q.db.QueryRow(ctx, getOrder, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OrderNumber,
		&i.PaymentStatus,
		&i.OrderStatus,
		&i.StoreID,
		&i.CustomerID,
	)
	return i, err
}

const getOrderItem = `-- name: GetOrderItem :one
SELECT id, created_at, updated_at, product_item_id, quantity, order_id FROM order_items
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetOrderItem(ctx context.Context, id string) (OrderItem, error) {
	row := q.db.QueryRow(ctx, getOrderItem, id)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProductItemID,
		&i.Quantity,
		&i.OrderID,
	)
	return i, err
}

const getProduct = `-- name: GetProduct :one
SELECT p.id, p.created_at, p.updated_at, p.name, p.description, p.rating, p.is_featured, p.is_archived, p.has_variants, p.category_id, p.store_id, p.category_name, p.variants,
       COALESCE(
       json_agg(json_build_object(
           'id', pi.id,
           'sku', pi.sku,
           'quantity', pi.quantity,
           'price', pi.price,
           'discounted_price', pi.discounted_price,
           'cost_price', pi.cost_price,
           'options', pi.options
       )) ,'[]'::json
       ) AS product_items
FROM products p
LEFT JOIN product_items pi ON p.id = pi.product_id
WHERE p.id = $1
GROUP BY p.id
`

type GetProductRow struct {
	ID           string           `json:"id"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	UpdatedAt    pgtype.Timestamp `json:"updated_at"`
	Name         string           `json:"name"`
	Description  pgtype.Text      `json:"description"`
	Rating       pgtype.Float8    `json:"rating"`
	IsFeatured   pgtype.Bool      `json:"is_featured"`
	IsArchived   pgtype.Bool      `json:"is_archived"`
	HasVariants  pgtype.Bool      `json:"has_variants"`
	CategoryID   string           `json:"category_id"`
	StoreID      string           `json:"store_id"`
	CategoryName string           `json:"category_name"`
	Variants     json.RawMessage  `json:"variants"`
	ProductItems interface{}      `json:"product_items"`
}

func (q *Queries) GetProduct(ctx context.Context, id string) (GetProductRow, error) {
	row := q.db.QueryRow(ctx, getProduct, id)
	var i GetProductRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.Rating,
		&i.IsFeatured,
		&i.IsArchived,
		&i.HasVariants,
		&i.CategoryID,
		&i.StoreID,
		&i.CategoryName,
		&i.Variants,
		&i.ProductItems,
	)
	return i, err
}

const getProductImage = `-- name: GetProductImage :one
SELECT id, created_at, updated_at, product_item_id, image_url FROM product_images
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetProductImage(ctx context.Context, id string) (ProductImage, error) {
	row := q.db.QueryRow(ctx, getProductImage, id)
	var i ProductImage
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProductItemID,
		&i.ImageUrl,
	)
	return i, err
}

const getProductItem = `-- name: GetProductItem :one
SELECT id, created_at, updated_at, product_id, sku, quantity, price, discounted_price, cost_price, options FROM product_items
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetProductItem(ctx context.Context, id string) (ProductItem, error) {
	row := q.db.QueryRow(ctx, getProductItem, id)
	var i ProductItem
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProductID,
		&i.Sku,
		&i.Quantity,
		&i.Price,
		&i.DiscountedPrice,
		&i.CostPrice,
		&i.Options,
	)
	return i, err
}

const getProducts = `-- name: GetProducts :many
WITH product_price_info AS (
    SELECT p.id,
           MIN(pi.price) AS min_price
    FROM products p
    LEFT JOIN product_items pi ON p.id = pi.product_id
    GROUP BY p.id
),
variant_filters AS (
    SELECT jsonb_object_keys($8::jsonb) AS variant_name,
           jsonb_array_elements_text($8::jsonb->jsonb_object_keys($8::jsonb)) AS variant_value
)
SELECT p.id, p.created_at, p.updated_at, p.name, p.description, p.rating, p.is_featured, p.is_archived, p.has_variants, p.category_id, p.store_id, p.category_name, p.variants,
       COALESCE(json_agg(json_build_object(
           'id', pi.id,
           'sku', pi.sku,
           'quantity', pi.quantity,
           'price', pi.price,
           'discounted_price', pi.discounted_price,
           'cost_price', pi.cost_price,
           'options', pi.options
       )) FILTER (WHERE pi.id IS NOT NULL), '[]'::json) AS product_items,
       ppi.min_price
FROM products p
LEFT JOIN product_items pi ON p.id = pi.product_id
JOIN product_price_info ppi ON p.id = ppi.id
WHERE p.store_id = $1
    AND ($2::text IS NULL OR p.category_id = $2)
    AND ($3::boolean IS NULL OR p.is_featured = $3)
    AND ($4::boolean IS NULL OR p.is_archived = $4)
    AND ($5::decimal IS NULL OR ppi.min_price >= $5)
    AND ($6::decimal IS NULL OR ppi.min_price <= $6)
    AND ($7::text IS NULL OR p.name ILIKE '%' || $7 || '%' OR p.description ILIKE '%' || $7 || '%')
    AND (
        $8::jsonb IS NULL
        OR EXISTS (
            SELECT 1
            FROM product_items sub_pi
            WHERE sub_pi.product_id = p.id
            AND (
                SELECT bool_and(
                    sub_pi.options ->> vf.variant_name IN (
                        SELECT jsonb_array_elements_text($8::jsonb->vf.variant_name)
                    )
                )
                FROM variant_filters vf
            )
        )
    )
GROUP BY p.id, ppi.min_price
LIMIT COALESCE($10::integer, 10)
OFFSET COALESCE($9::integer, 0)
`

type GetProductsParams struct {
	StoreID    pgtype.Text     `json:"store_id"`
	CategoryID pgtype.Text     `json:"category_id"`
	IsFeatured pgtype.Bool     `json:"is_featured"`
	IsArchived pgtype.Bool     `json:"is_archived"`
	MinPrice   pgtype.Numeric  `json:"min_price"`
	MaxPrice   pgtype.Numeric  `json:"max_price"`
	Search     pgtype.Text     `json:"search"`
	Variants   json.RawMessage `json:"variants"`
	Offset     pgtype.Int4     `json:"offset"`
	Limit      pgtype.Int4     `json:"limit"`
}

type GetProductsRow struct {
	ID           string           `json:"id"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	UpdatedAt    pgtype.Timestamp `json:"updated_at"`
	Name         string           `json:"name"`
	Description  pgtype.Text      `json:"description"`
	Rating       pgtype.Float8    `json:"rating"`
	IsFeatured   pgtype.Bool      `json:"is_featured"`
	IsArchived   pgtype.Bool      `json:"is_archived"`
	HasVariants  pgtype.Bool      `json:"has_variants"`
	CategoryID   string           `json:"category_id"`
	StoreID      string           `json:"store_id"`
	CategoryName string           `json:"category_name"`
	Variants     json.RawMessage  `json:"variants"`
	ProductItems interface{}      `json:"product_items"`
	MinPrice     interface{}      `json:"min_price"`
}

func (q *Queries) GetProducts(ctx context.Context, arg GetProductsParams) ([]GetProductsRow, error) {
	rows, err := q.db.Query(ctx, getProducts,
		arg.StoreID,
		arg.CategoryID,
		arg.IsFeatured,
		arg.IsArchived,
		arg.MinPrice,
		arg.MaxPrice,
		arg.Search,
		arg.Variants,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsRow
	for rows.Next() {
		var i GetProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Description,
			&i.Rating,
			&i.IsFeatured,
			&i.IsArchived,
			&i.HasVariants,
			&i.CategoryID,
			&i.StoreID,
			&i.CategoryName,
			&i.Variants,
			&i.ProductItems,
			&i.MinPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStore = `-- name: GetStore :one
SELECT id, created_at, updated_at, name, description, user_id FROM stores
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetStore(ctx context.Context, id string) (Store, error) {
	row := q.db.QueryRow(ctx, getStore, id)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.UserID,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, created_at, updated_at, username, email, password, role, store_id FROM users
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.StoreID,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, created_at, updated_at, username, email, password, role, store_id FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.StoreID,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, created_at, updated_at, username, email, password, role, store_id FROM users
WHERE username = $1 LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.StoreID,
	)
	return i, err
}

const getVariant = `-- name: GetVariant :one
SELECT id, created_at, updated_at, name, description, options, store_id FROM variants
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetVariant(ctx context.Context, id string) (Variant, error) {
	row := q.db.QueryRow(ctx, getVariant, id)
	var i Variant
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.Options,
		&i.StoreID,
	)
	return i, err
}

const listAddresses = `-- name: ListAddresses :many
SELECT id, created_at, updated_at, address_line_1, address_line_2, city, pincode, country_id FROM addresses
WHERE country_id = $1
ORDER BY created_at
LIMIT $2 OFFSET $3
`

type ListAddressesParams struct {
	CountryID string `json:"country_id"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

func (q *Queries) ListAddresses(ctx context.Context, arg ListAddressesParams) ([]Address, error) {
	rows, err := q.db.Query(ctx, listAddresses, arg.CountryID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Address
	for rows.Next() {
		var i Address
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AddressLine1,
			&i.AddressLine2,
			&i.City,
			&i.Pincode,
			&i.CountryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCartItems = `-- name: ListCartItems :many
SELECT id, created_at, updated_at, product_item_id, quantity, cart_id FROM cart_items
WHERE cart_id = $1
ORDER BY created_at
LIMIT $2 OFFSET $3
`

type ListCartItemsParams struct {
	CartID string `json:"cart_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListCartItems(ctx context.Context, arg ListCartItemsParams) ([]CartItem, error) {
	rows, err := q.db.Query(ctx, listCartItems, arg.CartID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CartItem
	for rows.Next() {
		var i CartItem
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductItemID,
			&i.Quantity,
			&i.CartID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCategories = `-- name: ListCategories :many
SELECT id, created_at, updated_at, name, description, store_id, parent_category_id, variants FROM categories
WHERE store_id = $1
ORDER BY created_at
`

func (q *Queries) ListCategories(ctx context.Context, storeID string) ([]Category, error) {
	rows, err := q.db.Query(ctx, listCategories, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Description,
			&i.StoreID,
			&i.ParentCategoryID,
			&i.Variants,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCountries = `-- name: ListCountries :many
SELECT id, created_at, updated_at, country FROM countries
ORDER BY country
LIMIT $1 OFFSET $2
`

type ListCountriesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListCountries(ctx context.Context, arg ListCountriesParams) ([]Country, error) {
	rows, err := q.db.Query(ctx, listCountries, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Country
	for rows.Next() {
		var i Country
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Country,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrderItems = `-- name: ListOrderItems :many
SELECT id, created_at, updated_at, product_item_id, quantity, order_id FROM order_items
WHERE order_id = $1
ORDER BY created_at
LIMIT $2 OFFSET $3
`

type ListOrderItemsParams struct {
	OrderID string `json:"order_id"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

func (q *Queries) ListOrderItems(ctx context.Context, arg ListOrderItemsParams) ([]OrderItem, error) {
	rows, err := q.db.Query(ctx, listOrderItems, arg.OrderID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrderItem
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductItemID,
			&i.Quantity,
			&i.OrderID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrders = `-- name: ListOrders :many
SELECT id, created_at, updated_at, order_number, payment_status, order_status, store_id, customer_id FROM orders
WHERE store_id = $1
ORDER BY created_at
LIMIT $2 OFFSET $3
`

type ListOrdersParams struct {
	StoreID string `json:"store_id"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

func (q *Queries) ListOrders(ctx context.Context, arg ListOrdersParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, listOrders, arg.StoreID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OrderNumber,
			&i.PaymentStatus,
			&i.OrderStatus,
			&i.StoreID,
			&i.CustomerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductImages = `-- name: ListProductImages :many
SELECT id, created_at, updated_at, product_item_id, image_url FROM product_images
WHERE product_item_id = $1
ORDER BY created_at
LIMIT $2 OFFSET $3
`

type ListProductImagesParams struct {
	ProductItemID string `json:"product_item_id"`
	Limit         int32  `json:"limit"`
	Offset        int32  `json:"offset"`
}

func (q *Queries) ListProductImages(ctx context.Context, arg ListProductImagesParams) ([]ProductImage, error) {
	rows, err := q.db.Query(ctx, listProductImages, arg.ProductItemID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductImage
	for rows.Next() {
		var i ProductImage
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductItemID,
			&i.ImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductItems = `-- name: ListProductItems :many
SELECT id, created_at, updated_at, product_id, sku, quantity, price, discounted_price, cost_price, options FROM product_items
WHERE product_id = $1
ORDER BY created_at
LIMIT $2 OFFSET $3
`

type ListProductItemsParams struct {
	ProductID string `json:"product_id"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

func (q *Queries) ListProductItems(ctx context.Context, arg ListProductItemsParams) ([]ProductItem, error) {
	rows, err := q.db.Query(ctx, listProductItems, arg.ProductID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductItem
	for rows.Next() {
		var i ProductItem
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductID,
			&i.Sku,
			&i.Quantity,
			&i.Price,
			&i.DiscountedPrice,
			&i.CostPrice,
			&i.Options,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStores = `-- name: ListStores :many
SELECT id, created_at, updated_at, name, description, user_id FROM stores
ORDER BY created_at
LIMIT $1 OFFSET $2
`

type ListStoresParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListStores(ctx context.Context, arg ListStoresParams) ([]Store, error) {
	rows, err := q.db.Query(ctx, listStores, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Store
	for rows.Next() {
		var i Store
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Description,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, created_at, updated_at, username, email, password, role, store_id FROM users
ORDER BY created_at
LIMIT $1 OFFSET $2
`

type ListUsersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Username,
			&i.Email,
			&i.Password,
			&i.Role,
			&i.StoreID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVariants = `-- name: ListVariants :many
SELECT id, created_at, updated_at, name, description, options, store_id FROM variants
WHERE store_id = $1
ORDER BY created_at
`

func (q *Queries) ListVariants(ctx context.Context, storeID string) ([]Variant, error) {
	rows, err := q.db.Query(ctx, listVariants, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Variant
	for rows.Next() {
		var i Variant
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Description,
			&i.Options,
			&i.StoreID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAddress = `-- name: UpdateAddress :one
UPDATE addresses
SET address_line_1 = $2, address_line_2 = $3, city = $4, pincode = $5, country_id = $6, updated_at = $7
WHERE id = $1
RETURNING id, created_at, updated_at, address_line_1, address_line_2, city, pincode, country_id
`

type UpdateAddressParams struct {
	ID           string           `json:"id"`
	AddressLine1 string           `json:"address_line_1"`
	AddressLine2 pgtype.Text      `json:"address_line_2"`
	City         string           `json:"city"`
	Pincode      string           `json:"pincode"`
	CountryID    string           `json:"country_id"`
	UpdatedAt    pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) UpdateAddress(ctx context.Context, arg UpdateAddressParams) (Address, error) {
	row := q.db.QueryRow(ctx, updateAddress,
		arg.ID,
		arg.AddressLine1,
		arg.AddressLine2,
		arg.City,
		arg.Pincode,
		arg.CountryID,
		arg.UpdatedAt,
	)
	var i Address
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.City,
		&i.Pincode,
		&i.CountryID,
	)
	return i, err
}

const updateCart = `-- name: UpdateCart :one
UPDATE carts
SET total_price = $2, total_discounted_price = $3, total_quantity = $4, updated_at = $5
WHERE id = $1
RETURNING id, created_at, updated_at, customer_id, total_price, total_discounted_price, total_quantity
`

type UpdateCartParams struct {
	ID                   string           `json:"id"`
	TotalPrice           float64          `json:"total_price"`
	TotalDiscountedPrice pgtype.Float8    `json:"total_discounted_price"`
	TotalQuantity        int32            `json:"total_quantity"`
	UpdatedAt            pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) UpdateCart(ctx context.Context, arg UpdateCartParams) (Cart, error) {
	row := q.db.QueryRow(ctx, updateCart,
		arg.ID,
		arg.TotalPrice,
		arg.TotalDiscountedPrice,
		arg.TotalQuantity,
		arg.UpdatedAt,
	)
	var i Cart
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CustomerID,
		&i.TotalPrice,
		&i.TotalDiscountedPrice,
		&i.TotalQuantity,
	)
	return i, err
}

const updateCartItem = `-- name: UpdateCartItem :one
UPDATE cart_items
SET quantity = $2, updated_at = $3
WHERE id = $1
RETURNING id, created_at, updated_at, product_item_id, quantity, cart_id
`

type UpdateCartItemParams struct {
	ID        string           `json:"id"`
	Quantity  int32            `json:"quantity"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) UpdateCartItem(ctx context.Context, arg UpdateCartItemParams) (CartItem, error) {
	row := q.db.QueryRow(ctx, updateCartItem, arg.ID, arg.Quantity, arg.UpdatedAt)
	var i CartItem
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProductItemID,
		&i.Quantity,
		&i.CartID,
	)
	return i, err
}

const updateCategory = `-- name: UpdateCategory :one
UPDATE categories
SET name = $2, description = $3, parent_category_id = $4, variants = $5, updated_at = $6
WHERE id = $1 AND store_id = $7
RETURNING id, created_at, updated_at, name, description, store_id, parent_category_id, variants
`

type UpdateCategoryParams struct {
	ID               string           `json:"id"`
	Name             string           `json:"name"`
	Description      pgtype.Text      `json:"description"`
	ParentCategoryID pgtype.Text      `json:"parent_category_id"`
	Variants         json.RawMessage  `json:"variants"`
	UpdatedAt        pgtype.Timestamp `json:"updated_at"`
	StoreID          string           `json:"store_id"`
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) (Category, error) {
	row := q.db.QueryRow(ctx, updateCategory,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.ParentCategoryID,
		arg.Variants,
		arg.UpdatedAt,
		arg.StoreID,
	)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.StoreID,
		&i.ParentCategoryID,
		&i.Variants,
	)
	return i, err
}

const updateCountry = `-- name: UpdateCountry :one
UPDATE countries
SET country = $2, updated_at = $3
WHERE id = $1
RETURNING id, created_at, updated_at, country
`

type UpdateCountryParams struct {
	ID        string           `json:"id"`
	Country   string           `json:"country"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) UpdateCountry(ctx context.Context, arg UpdateCountryParams) (Country, error) {
	row := q.db.QueryRow(ctx, updateCountry, arg.ID, arg.Country, arg.UpdatedAt)
	var i Country
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Country,
	)
	return i, err
}

const updateOrder = `-- name: UpdateOrder :one
UPDATE orders
SET payment_status = $2, order_status = $3, updated_at = $4
WHERE id = $1
RETURNING id, created_at, updated_at, order_number, payment_status, order_status, store_id, customer_id
`

type UpdateOrderParams struct {
	ID            string           `json:"id"`
	PaymentStatus string           `json:"payment_status"`
	OrderStatus   string           `json:"order_status"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrder,
		arg.ID,
		arg.PaymentStatus,
		arg.OrderStatus,
		arg.UpdatedAt,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OrderNumber,
		&i.PaymentStatus,
		&i.OrderStatus,
		&i.StoreID,
		&i.CustomerID,
	)
	return i, err
}

const updateOrderItem = `-- name: UpdateOrderItem :one
UPDATE order_items
SET quantity = $2, updated_at = $3
WHERE id = $1
RETURNING id, created_at, updated_at, product_item_id, quantity, order_id
`

type UpdateOrderItemParams struct {
	ID        string           `json:"id"`
	Quantity  int32            `json:"quantity"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) UpdateOrderItem(ctx context.Context, arg UpdateOrderItemParams) (OrderItem, error) {
	row := q.db.QueryRow(ctx, updateOrderItem, arg.ID, arg.Quantity, arg.UpdatedAt)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProductItemID,
		&i.Quantity,
		&i.OrderID,
	)
	return i, err
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products
SET name = $2, description = $3, rating = $4, is_featured = $5, is_archived = $6, has_variants = $7, category_id = $8, category_name = $9, variants = $10, updated_at = $11
WHERE id = $1 AND store_id = $12
RETURNING id, created_at, updated_at, name, description, rating, is_featured, is_archived, has_variants, category_id, store_id, category_name, variants
`

type UpdateProductParams struct {
	ID           string           `json:"id"`
	Name         string           `json:"name"`
	Description  pgtype.Text      `json:"description"`
	Rating       pgtype.Float8    `json:"rating"`
	IsFeatured   pgtype.Bool      `json:"is_featured"`
	IsArchived   pgtype.Bool      `json:"is_archived"`
	HasVariants  pgtype.Bool      `json:"has_variants"`
	CategoryID   string           `json:"category_id"`
	CategoryName string           `json:"category_name"`
	Variants     json.RawMessage  `json:"variants"`
	UpdatedAt    pgtype.Timestamp `json:"updated_at"`
	StoreID      string           `json:"store_id"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProduct,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Rating,
		arg.IsFeatured,
		arg.IsArchived,
		arg.HasVariants,
		arg.CategoryID,
		arg.CategoryName,
		arg.Variants,
		arg.UpdatedAt,
		arg.StoreID,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.Rating,
		&i.IsFeatured,
		&i.IsArchived,
		&i.HasVariants,
		&i.CategoryID,
		&i.StoreID,
		&i.CategoryName,
		&i.Variants,
	)
	return i, err
}

const updateProductImage = `-- name: UpdateProductImage :one
UPDATE product_images
SET image_url = $2, updated_at = $3
WHERE id = $1
RETURNING id, created_at, updated_at, product_item_id, image_url
`

type UpdateProductImageParams struct {
	ID        string           `json:"id"`
	ImageUrl  string           `json:"image_url"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) UpdateProductImage(ctx context.Context, arg UpdateProductImageParams) (ProductImage, error) {
	row := q.db.QueryRow(ctx, updateProductImage, arg.ID, arg.ImageUrl, arg.UpdatedAt)
	var i ProductImage
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProductItemID,
		&i.ImageUrl,
	)
	return i, err
}

const updateProductItem = `-- name: UpdateProductItem :one
UPDATE product_items
SET sku = $2, quantity = $3, price = $4, discounted_price = $5, cost_price = $6, options = $7, updated_at = $8
WHERE id = $1
RETURNING id, created_at, updated_at, product_id, sku, quantity, price, discounted_price, cost_price, options
`

type UpdateProductItemParams struct {
	ID              string           `json:"id"`
	Sku             string           `json:"sku"`
	Quantity        int32            `json:"quantity"`
	Price           float64          `json:"price"`
	DiscountedPrice pgtype.Float8    `json:"discounted_price"`
	CostPrice       pgtype.Float8    `json:"cost_price"`
	Options         json.RawMessage  `json:"options"`
	UpdatedAt       pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) UpdateProductItem(ctx context.Context, arg UpdateProductItemParams) (ProductItem, error) {
	row := q.db.QueryRow(ctx, updateProductItem,
		arg.ID,
		arg.Sku,
		arg.Quantity,
		arg.Price,
		arg.DiscountedPrice,
		arg.CostPrice,
		arg.Options,
		arg.UpdatedAt,
	)
	var i ProductItem
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProductID,
		&i.Sku,
		&i.Quantity,
		&i.Price,
		&i.DiscountedPrice,
		&i.CostPrice,
		&i.Options,
	)
	return i, err
}

const updateStore = `-- name: UpdateStore :one
UPDATE stores
SET name = $2, description = $3, updated_at = $4
WHERE id = $1
RETURNING id, created_at, updated_at, name, description, user_id
`

type UpdateStoreParams struct {
	ID          string           `json:"id"`
	Name        string           `json:"name"`
	Description pgtype.Text      `json:"description"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) UpdateStore(ctx context.Context, arg UpdateStoreParams) (Store, error) {
	row := q.db.QueryRow(ctx, updateStore,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.UpdatedAt,
	)
	var i Store
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.UserID,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET username = $2, email = $3, password = $4, role = $5, store_id = $6, updated_at = $7
WHERE id = $1
RETURNING id, created_at, updated_at, username, email, password, role, store_id
`

type UpdateUserParams struct {
	ID        string           `json:"id"`
	Username  string           `json:"username"`
	Email     string           `json:"email"`
	Password  string           `json:"password"`
	Role      string           `json:"role"`
	StoreID   pgtype.Text      `json:"store_id"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.ID,
		arg.Username,
		arg.Email,
		arg.Password,
		arg.Role,
		arg.StoreID,
		arg.UpdatedAt,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.Role,
		&i.StoreID,
	)
	return i, err
}

const updateVariant = `-- name: UpdateVariant :one
UPDATE variants
SET name = $2, description = $3, options = $4, updated_at = $5
WHERE id = $1 AND store_id = $6
RETURNING id, created_at, updated_at, name, description, options, store_id
`

type UpdateVariantParams struct {
	ID          string           `json:"id"`
	Name        string           `json:"name"`
	Description pgtype.Text      `json:"description"`
	Options     json.RawMessage  `json:"options"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
	StoreID     string           `json:"store_id"`
}

func (q *Queries) UpdateVariant(ctx context.Context, arg UpdateVariantParams) (Variant, error) {
	row := q.db.QueryRow(ctx, updateVariant,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Options,
		arg.UpdatedAt,
		arg.StoreID,
	)
	var i Variant
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.Options,
		&i.StoreID,
	)
	return i, err
}
